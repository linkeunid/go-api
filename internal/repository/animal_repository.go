package repository

import (
	"context"
	"errors"
	"fmt"

	"github.com/linkeunid/go-api/internal/model"
	"github.com/linkeunid/go-api/pkg/database"
	"github.com/linkeunid/go-api/pkg/pagination"
	"go.uber.org/zap"
	"gorm.io/gorm"
)

// AnimalRepository defines the interface for animal data access
type AnimalRepository interface {
	FindAll(ctx context.Context) ([]model.Animal, error)
	FindAllPaginated(ctx context.Context, params pagination.Params) ([]model.Animal, pagination.Params, error)
	FindByID(ctx context.Context, id uint64) (*model.Animal, error)
	Create(ctx context.Context, animal *model.Animal) error
	Update(ctx context.Context, animal *model.Animal) error
	Delete(ctx context.Context, id uint64) error
}

// mysqlAnimalRepository implements AnimalRepository using MySQL with Redis cache
type mysqlAnimalRepository struct {
	db     database.Database
	logger *zap.Logger
}

// NewAnimalRepository creates a new animal repository
func NewAnimalRepository(db database.Database, logger *zap.Logger) AnimalRepository {
	return &mysqlAnimalRepository{
		db:     db,
		logger: logger,
	}
}

// FindAll retrieves all animals with caching
func (r *mysqlAnimalRepository) FindAll(ctx context.Context) ([]model.Animal, error) {
	var animals []model.Animal

	// Build the query
	query := r.db.GetDB().Order("created_at DESC")

	// Use cached find with default TTL
	err := r.db.CachedFind(ctx, query, &animals)
	if err != nil {
		r.logger.Error("Failed to retrieve animals", zap.Error(err))
		return nil, err
	}

	return animals, nil
}

// FindAllPaginated retrieves paginated animals
func (r *mysqlAnimalRepository) FindAllPaginated(ctx context.Context, params pagination.Params) ([]model.Animal, pagination.Params, error) {
	var animals []model.Animal

	// Get sort field and direction from query parameters
	sortField := "id"      // Default sort field
	sortDirection := "asc" // Default sort direction

	// Query values
	values := ctx.Value("queryParams")
	if values != nil {
		if queryParams, ok := values.(map[string]string); ok {
			if field, exists := queryParams["sort"]; exists && field != "" {
				// Basic sanitization to prevent SQL injection
				allowedFields := map[string]bool{"id": true, "name": true, "species": true, "age": true, "created_at": true, "updated_at": true}
				if allowedFields[field] {
					sortField = field
				}
			}

			if dir, exists := queryParams["direction"]; exists {
				if dir == "desc" {
					sortDirection = "desc"
				}
			}
		}
	}

	// Build the base query with explicit model
	baseQuery := r.db.GetDB().Model(&model.Animal{})

	// Apply sorting
	orderClause := fmt.Sprintf("%s %s", sortField, sortDirection)
	baseQuery = baseQuery.Order(orderClause)

	// Count total rows
	var totalRows int64
	if err := baseQuery.Count(&totalRows).Error; err != nil {
		r.logger.Error("Failed to count animals", zap.Error(err))
		return nil, params, err
	}

	// Calculate pagination metadata
	params.CalculatePages(totalRows)

	// Apply pagination limits and get results
	if err := baseQuery.Offset(params.GetOffset()).Limit(params.Limit).Find(&animals).Error; err != nil {
		r.logger.Error("Failed to retrieve paginated animals", zap.Error(err))
		return nil, params, err
	}

	return animals, params, nil
}

// FindByID retrieves an animal by ID with caching
func (r *mysqlAnimalRepository) FindByID(ctx context.Context, id uint64) (*model.Animal, error) {
	if id == 0 {
		return nil, errors.New("invalid ID")
	}

	var animal model.Animal

	// Build the query
	query := r.db.GetDB().Where("id = ?", id)

	// Use cached find
	err := r.db.CachedFind(ctx, query, &animal)
	if err != nil {
		if err == gorm.ErrRecordNotFound {
			return nil, nil // Return nil, nil for not found
		}
		r.logger.Error("Failed to retrieve animal by ID", zap.Uint64("id", id), zap.Error(err))
		return nil, err
	}

	// Check if the record was actually found (GORM might not return ErrRecordNotFound)
	if animal.ID == 0 {
		return nil, nil // Return nil, nil for not found
	}

	return &animal, nil
}

// Create saves a new animal
func (r *mysqlAnimalRepository) Create(ctx context.Context, animal *model.Animal) error {
	// Create the record (ID will be auto-generated by the database)
	if err := r.db.GetDB().Create(animal).Error; err != nil {
		r.logger.Error("Failed to create animal", zap.Error(err))
		return err
	}

	// Invalidate the cache for collection
	cacheManager := r.db.GetCacheManager()
	if cacheManager != nil && cacheManager.GetCache() != nil {
		cacheKey := "animals:all"
		if err := cacheManager.GetCache().Delete(ctx, cacheKey); err != nil {
			r.logger.Warn("Failed to invalidate animal collection cache", zap.Error(err))
		}
	}

	return nil
}

// Update updates an existing animal
func (r *mysqlAnimalRepository) Update(ctx context.Context, animal *model.Animal) error {
	if animal.ID == 0 {
		return errors.New("invalid ID")
	}

	if err := r.db.GetDB().Save(animal).Error; err != nil {
		r.logger.Error("Failed to update animal", zap.Uint64("id", animal.ID), zap.Error(err))
		return err
	}

	// Invalidate caches
	cacheManager := r.db.GetCacheManager()
	if cacheManager != nil && cacheManager.GetCache() != nil {
		// Invalidate individual animal cache
		cacheKey := animal.CacheKey()
		if err := cacheManager.GetCache().Delete(ctx, cacheKey); err != nil {
			r.logger.Warn("Failed to invalidate animal cache", zap.Uint64("id", animal.ID), zap.Error(err))
		}

		// Also invalidate collection cache
		collectionKey := "animals:all"
		if err := cacheManager.GetCache().Delete(ctx, collectionKey); err != nil {
			r.logger.Warn("Failed to invalidate animal collection cache", zap.Error(err))
		}
	}

	return nil
}

// Delete removes an animal
func (r *mysqlAnimalRepository) Delete(ctx context.Context, id uint64) error {
	if id == 0 {
		return errors.New("invalid ID")
	}

	if err := r.db.GetDB().Delete(&model.Animal{}, id).Error; err != nil {
		r.logger.Error("Failed to delete animal", zap.Uint64("id", id), zap.Error(err))
		return err
	}

	// Invalidate caches
	cacheManager := r.db.GetCacheManager()
	if cacheManager != nil && cacheManager.GetCache() != nil {
		// Invalidate individual cache
		cacheKey := fmt.Sprintf("animal:%d", id)
		if err := cacheManager.GetCache().Delete(ctx, cacheKey); err != nil {
			r.logger.Warn("Failed to invalidate animal cache", zap.Uint64("id", id), zap.Error(err))
		}

		// Also invalidate collection cache
		collectionKey := "animals:all"
		if err := cacheManager.GetCache().Delete(ctx, collectionKey); err != nil {
			r.logger.Warn("Failed to invalidate animal collection cache", zap.Error(err))
		}
	}

	return nil
}
